{"version":3,"sources":["lianxi.js"],"names":[],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,WAAW,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAY;AACnC,YAAQ,GAAR;AACA,WAAO,QAAP;AACH,CAHc,CAAf;;AAKA,SAAS,IAAT,CAAc,UAAC,KAAD,EAAU;AACpB,YAAQ,GAAR,CAAY,KAAZ;AACA,WAAO,QAAQ,CAAf;AACH,CAHD,EAGG,IAHH,CAGQ,UAAC,KAAD,EAAS;AACb,YAAQ,GAAR,CAAY,KAAZ;AACA,WAAO,QAAQ,CAAf;AACH,CAND,EAMG,IANH,CAMQ,UAAC,KAAD,EAAS;AACb,YAAQ,GAAR,CAAY,KAAZ;AACH,CARD;AASA;AACA;AACA;AACA,SAAS,IAAT,CAAc,UAAU,KAAV,EAAiB;AAC3B,YAAQ,GAAR,CAAY,QAAQ,KAApB,EAD2B,CACC;AAC/B,CAFD,EAEG,IAFH,CAEQ,UAAC,KAAD,EAAS;AACb,YAAQ,GAAR,CAAY,KAAZ;AACH,CAJD","file":"lianxi-compiled.js","sourcesContent":["// var aa=function(x){\n//        var p=new Promise((resolve,reject)=>{\n//            if(x>5){\n//                x++;\n//                resolve(x);\n//            }else{\n//                x--;\n//                reject(x);\n//            }\n//        })\n//        return p;\n//    };\n//    aa(4).then((data)=>{\n//        console.log(\"ok\"+data);\n//    },(data)=>{\n//        console.log(\"fail\"+data);\n//    }).then((data)=>{\n//        console.log('ok1'+data)\n//    },(data)=>{\n//        console.log('fail1'+data)\n//    })\n//     var aa=function(m){\n//         var p=new Promise((resolve,reject)=>{\n//             setTimeout(()=>{\n//                 resolve(m)\n//             })\n//         })\n//     };\n// aa('nz').then(()=>{\n//     console.log('这是第一个then');\n//     console.log(data);\n//     return data+'is';\n// }).then(()=>{\n//     console.log('这是第二个then');\n//     console.log(data);\n//     return data+'luck';\n// }).then(()=>{\n//     console.log('这是san个then');\n//     console.log(data);\n//     return new Promise((resolve,reject)=>{\n//         reject('reject拒绝了')\n//     })\n// }).then(()=>{\n//     console.log('resolve')\n// },(data)=>{\n//     console.log(data);\n// })\n//\n//     var p1=new Promise((resolve,reject)=>{\n//         resolve(10);\n//     });\n//     var p2=new Promise((resolve,reject)=>{\n//         relove(20);\n//     });\n//     var p3=new Promise((resolve,reject)=>{\n//         resolve(30);\n//     });\n//     Promise.all([p1,p2,p3]).then((data)=>{\n//         console.log(data);\n//     },(data)=>{\n//         console.log()\n//     });\n// var reqPic=new Promise((resolve,reject)=>{\n//         var img=new Image();\n//         img.src=\"aaa.jpg\";\n//         img.onload=()=>{\n//             resolve(img);\n//         }\n//     });\n//     var picTimeOut=new Promise((resolve,reject)=>{\n//         setTimeout(()=>{\n//             reject(\"图片请求超时\")\n//         },5000)\n//     });\n//     Promise.race([reqPic,picTimeOut]).then((res)=>{\n//         console.log(res);\n//     }).catch((res)=>{\n//         console.log(res);\n//     })\n//取最大值 由于max()里面参数不能为数组，所以借助apply(funtion,args)方法调用Math.max()，\n// function为要调用的方法，args是数组对象，当function为null时，\n// 默认为上文,即相当于apply(Math.max,arr)\n// var arr=[21,17,99,28];\n// var max = Math.max.apply(null,arr);\n// console.log(max)\n// var max1 = Math.max.call(null,7,2,0,-3,5)\n// console.log(max1)\n// var array = [1, 2, 3];\n// console.log(Math.max(...array));\n// const p1=new Promise((resolve,reject)=>{\n//     resolve('hello');\n// });\n// const p2=new Promise((resolve,reject)=>{\n//     reject('报错了')\n// }).then(result=>result).catch(e=>e);\n// Promise.all([p1,p2]).then(result=>console.log(result)).catch(e=>console.log(e));\n// function runAsync1(){\n//     var p = new Promise(function(resolve, reject){\n//         //做一些异步操作\n//         setTimeout(function(){\n//             console.log('异步任务1执行完成');\n//             reject('随便什么数据1');\n//         }, 1000);\n//     });\n//     return p;\n// }\n// function runAsync2(){\n//     var p = new Promise(function(resolve, reject){\n//         //做一些异步操作\n//         setTimeout(function(){\n//             reject('随便什么数据2');\n//             console.log('异步任务2执行完成');\n//\n//         }, 500);\n//     });\n//     return p;\n// }\n// function runAsync3(){\n//     var p = new Promise(function(resolve, reject){\n//         //做一些异步操作\n//         setTimeout(function(){\n//             console.log('异步任务3执行完成');\n//             resolve('随便什么数据3');\n//         }, 2000);\n//     });\n//     return p;\n// }\n\n// Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(data){console.log(data);\n// });//异步任务1执行完成 随便什么数据1 异步任务2执行完成 异步任务3 执行完成\n// //    在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志\nvar aPromise = new Promise((resolve)=> {\n    resolve(100);\n    return aPromise;\n});\n\naPromise.then((value)=> {\n    console.log(value)\n    return value * 2;\n}).then((value)=>{\n    console.log(value);\n    return value * 2;\n}).then((value)=>{\n    console.log(value);\n});\n// aPromise.then(function (value) {\n//\n// });\naPromise.then(function (value) {\n    console.log(\"1: \" + value); // => 10\n}).then((value)=>{\n    console.log(value);\n});"]}